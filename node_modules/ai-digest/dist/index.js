#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
const fs_1 = require("fs");
const fsSync = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const glob_1 = require("glob");
const ignore_1 = __importDefault(require("ignore"));
const chokidar = __importStar(require("chokidar"));
const utils_1 = require("./utils");
const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB in bytes
function getActualWorkingDirectory() {
    // INIT_CWD is set by npm/npx to the directory from which the command was invoked
    // This is more reliable than process.cwd() when running via npx
    if (process.env.INIT_CWD) {
        return process.env.INIT_CWD;
    }
    return process.cwd();
}
// Simple debounce function to avoid multiple rebuilds when many files change at once
function debounce(func, wait) {
    let timeout = null;
    return function (...args) {
        if (timeout) {
            clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
            func(...args);
            timeout = null;
        }, wait);
    };
}
async function readIgnoreFile(inputDir, filename) {
    try {
        const filePath = path_1.default.join(inputDir, filename);
        const content = await fs_1.promises.readFile(filePath, "utf-8");
        console.log((0, utils_1.formatLog)(`Found ${filename} file in ${inputDir}.`, "üìÑ"));
        return content
            .split("\n")
            .filter((line) => line.trim() !== "" && !line.startsWith("#"));
    }
    catch (error) {
        if (error.code === "ENOENT") {
            console.log((0, utils_1.formatLog)(`No ${filename} file found in ${inputDir}.`, "‚ùì"));
            return [];
        }
        throw error;
    }
}
function formatFileSize(bytes) {
    if (bytes < 1024)
        return `${bytes} B`;
    if (bytes < 1024 * 1024)
        return `${(bytes / 1024).toFixed(1)} KB`;
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}
function displayIncludedFiles(includedFiles, fileSizes, sortBySize = false) {
    console.log((0, utils_1.formatLog)("Files included in the output:", "üìã"));
    const totalSize = Object.values(fileSizes).reduce((sum, size) => sum + size, 0);
    let displayFiles = [...includedFiles];
    if (sortBySize) {
        displayFiles.sort((a, b) => fileSizes[b] - fileSizes[a]);
        console.log((0, utils_1.formatLog)("Files sorted by size (largest first)", "üìä"));
    }
    const maxFileNameLength = Math.min(60, // Cap at 60 characters to prevent very long lines
    displayFiles.reduce((max, file) => Math.max(max, file.length), 0));
    displayFiles.forEach((file, index) => {
        const size = fileSizes[file] || 0;
        const percentage = totalSize > 0 ? (size / totalSize) * 100 : 0;
        const barLength = Math.max(1, Math.round(percentage / 2)); // Scale bar length (2% = 1 character), min 1 char
        const bar = "‚ñà".repeat(barLength);
        console.log(`${(index + 1).toString().padEnd(4)}${file.padEnd(maxFileNameLength + 2)}${formatFileSize(size).padEnd(10)}(${percentage.toFixed(1).padStart(4)}%) ${bar}`);
    });
}
function naturalSort(a, b) {
    return a.localeCompare(b, undefined, { numeric: true, sensitivity: "base" });
}
// Track if a file write is in progress
let isWritingFile = false;
async function watchFiles(inputDirs, outputFile, useDefaultIgnores, removeWhitespaceFlag, showOutputFiles, ignoreFile, testMode = false) {
    try {
        // First, run the initial aggregation
        isWritingFile = true;
        await aggregateFiles(inputDirs, outputFile, useDefaultIgnores, removeWhitespaceFlag, showOutputFiles, ignoreFile);
        isWritingFile = false;
        console.log((0, utils_1.formatLog)("Watch mode enabled. Waiting for file changes...", "üëÄ"));
        // Exit early if in test mode to prevent hanging test
        if (testMode) {
            return;
        }
        // Read ignore patterns for each input directory
        const allIgnorePatterns = {};
        for (const inputDir of inputDirs) {
            allIgnorePatterns[inputDir] = await readIgnoreFile(inputDir, ignoreFile);
        }
        const defaultIgnore = useDefaultIgnores
            ? (0, ignore_1.default)().add(utils_1.DEFAULT_IGNORES)
            : (0, ignore_1.default)();
        // Create custom ignore filter for each directory
        const customIgnores = {};
        for (const inputDir of inputDirs) {
            customIgnores[inputDir] = (0, utils_1.createIgnoreFilter)(allIgnorePatterns[inputDir], ignoreFile);
        }
        // Function to determine if a file should be ignored
        function shouldIgnorePath(filePath) {
            if (!filePath)
                return true;
            // Skip node_modules and dot directories for performance
            if (filePath.includes("node_modules") || /\/\.[^\/]+\//.test(filePath)) {
                return true;
            }
            // Find the corresponding input directory for this file
            let matchingInputDir = "";
            for (const inputDir of inputDirs) {
                if (filePath.startsWith(inputDir)) {
                    matchingInputDir = inputDir;
                    break;
                }
            }
            if (!matchingInputDir)
                return true;
            // Get relative path for checking ignore patterns
            const relativePath = path_1.default.relative(matchingInputDir, filePath);
            // Skip empty relative paths
            if (!relativePath || relativePath === "") {
                return true;
            }
            // Ignore the output file
            const outputAbsPath = path_1.default.isAbsolute(outputFile)
                ? outputFile
                : path_1.default.join(getActualWorkingDirectory(), outputFile);
            if (filePath === outputAbsPath) {
                return true;
            }
            // Check against default ignore patterns
            if (useDefaultIgnores && defaultIgnore.ignores(relativePath)) {
                return true;
            }
            // Check against custom ignore patterns for this directory
            if (customIgnores[matchingInputDir].ignores(relativePath)) {
                return true;
            }
            return false;
        }
        // Create a debounced rebuild function
        const debouncedRebuild = debounce(async () => {
            try {
                console.log((0, utils_1.formatLog)("Changes detected, rebuilding...", "üîÑ"));
                isWritingFile = true;
                await aggregateFiles(inputDirs, outputFile, useDefaultIgnores, removeWhitespaceFlag, showOutputFiles, ignoreFile);
                isWritingFile = false;
                console.log((0, utils_1.formatLog)("Rebuild complete. Waiting for more changes...", "‚úÖ"));
            }
            catch (error) {
                isWritingFile = false;
                console.error((0, utils_1.formatLog)("Error during rebuild:", "‚ùå"), error);
            }
        }, 500); // Debounce for 500ms
        // Setup watchers for each input directory
        const watchers = [];
        for (const inputDir of inputDirs) {
            const watcher = chokidar.watch(inputDir, {
                persistent: true,
                ignoreInitial: true,
                // Only use minimal ignores in watcher configuration
                ignored: ["**/node_modules/**", "**/.*/**"],
            });
            // Log when ready
            watcher.on("ready", () => {
                console.log((0, utils_1.formatLog)(`Initial scan of ${inputDir} complete.`, "‚úÖ"));
            });
            // Handle all file events with our custom filtering
            watcher.on("all", (event, filePath) => {
                // Check if file should be ignored using our custom function
                if (!shouldIgnorePath(filePath)) {
                    const relativePath = path_1.default.relative(inputDir, filePath);
                    console.log((0, utils_1.formatLog)(`${event}: ${relativePath} in ${inputDir}`, "üîÑ"));
                    debouncedRebuild();
                }
            });
            watchers.push(watcher);
        }
        // Also watch the ignore files themselves for changes
        const ignoreWatchers = [];
        for (const inputDir of inputDirs) {
            const ignoreFilePath = path_1.default.join(inputDir, ignoreFile);
            try {
                const ignoreFileExists = await fs_1.promises
                    .access(ignoreFilePath)
                    .then(() => true)
                    .catch(() => false);
                if (ignoreFileExists) {
                    // Create a separate watcher just for the ignore file
                    const ignoreWatcher = chokidar.watch(ignoreFilePath, {
                        persistent: true,
                        ignoreInitial: true,
                    });
                    ignoreWatcher.on("change", () => {
                        console.log((0, utils_1.formatLog)(`${ignoreFile} in ${inputDir} changed, updating ignore patterns...`, "üìÑ"));
                        debouncedRebuild();
                    });
                    ignoreWatchers.push(ignoreWatcher);
                }
            }
            catch (error) {
                console.error((0, utils_1.formatLog)(`Error watching ${ignoreFile} in ${inputDir}:`, "‚ùå"), error);
            }
        }
        // Handle process termination
        process.on("SIGINT", () => {
            if (isWritingFile) {
                console.log((0, utils_1.formatLog)("Write in progress, waiting to complete...", "‚è≥"));
                // Set up a maximum wait time of 2 seconds
                const forceExitTimeout = setTimeout(() => {
                    console.log((0, utils_1.formatLog)("Timeout reached, forcing exit.", "‚ö†Ô∏è"));
                    process.exit(0);
                }, 2000);
                // Poll to check when writing is complete
                const checkInterval = setInterval(() => {
                    if (!isWritingFile) {
                        clearTimeout(forceExitTimeout);
                        clearInterval(checkInterval);
                        console.log((0, utils_1.formatLog)("Write complete. Watch mode terminated.", "üëã"));
                        process.exit(0);
                    }
                }, 100);
            }
            else {
                console.log((0, utils_1.formatLog)("Watch mode terminated.", "üëã"));
                process.exit(0);
            }
        });
        // Keep the process alive
        return new Promise(() => { });
    }
    catch (error) {
        console.error((0, utils_1.formatLog)("Error in watch mode:", "‚ùå"), error);
        process.exit(1);
    }
}
async function aggregateFiles(inputDirs, outputFile, useDefaultIgnores, removeWhitespaceFlag, showOutputFiles, ignoreFile) {
    try {
        // Object to store ignore patterns for each input directory
        const allIgnorePatterns = {};
        for (const inputDir of inputDirs) {
            allIgnorePatterns[inputDir] = await readIgnoreFile(inputDir, ignoreFile);
        }
        const defaultIgnore = useDefaultIgnores
            ? (0, ignore_1.default)().add(utils_1.DEFAULT_IGNORES)
            : (0, ignore_1.default)();
        // Create custom ignore filter for each directory
        const customIgnores = {};
        for (const inputDir of inputDirs) {
            customIgnores[inputDir] = (0, utils_1.createIgnoreFilter)(allIgnorePatterns[inputDir], ignoreFile);
        }
        if (useDefaultIgnores) {
            console.log((0, utils_1.formatLog)("Using default ignore patterns.", "üö´"));
        }
        else {
            console.log((0, utils_1.formatLog)("Default ignore patterns disabled.", "‚úÖ"));
        }
        if (removeWhitespaceFlag) {
            console.log((0, utils_1.formatLog)("Whitespace removal enabled (except for whitespace-dependent languages).", "üßπ"));
        }
        else {
            console.log((0, utils_1.formatLog)("Whitespace removal disabled.", "üìù"));
        }
        let allFileEntries = [];
        // Collect files from all input directories
        for (const inputDir of inputDirs) {
            console.log((0, utils_1.formatLog)(`Scanning directory: ${inputDir}`, "üîç"));
            const dirFiles = await (0, glob_1.glob)("**/*", {
                nodir: true,
                dot: true,
                cwd: inputDir,
            });
            console.log((0, utils_1.formatLog)(`Found ${dirFiles.length} files in ${inputDir}`, "üîç"));
            for (const file of dirFiles) {
                const fullPath = path_1.default.join(inputDir, file);
                allFileEntries.push({
                    relativePath: file,
                    fullPath,
                    sourceDir: inputDir,
                });
            }
        }
        if (inputDirs.length > 1) {
            console.log((0, utils_1.formatLog)(`Total files found across all directories: ${allFileEntries.length}`, "üîç"));
        }
        let output = "";
        let includedCount = 0;
        let defaultIgnoredCount = 0;
        let customIgnoredCount = 0;
        let binaryAndSvgFileCount = 0;
        let includedFiles = [];
        let fileSizes = {};
        // Sort the files in natural path order
        allFileEntries.sort((a, b) => naturalSort(a.relativePath, b.relativePath));
        for (const entry of allFileEntries) {
            const { relativePath, fullPath, sourceDir } = entry;
            // Generate a unique path for display that includes the source directory
            // But only add the source directory name when there are multiple directories
            const displayPath = inputDirs.length > 1
                ? `${path_1.default.basename(sourceDir)}/${relativePath}`
                : relativePath;
            const outputAbsPath = path_1.default.isAbsolute(outputFile)
                ? outputFile
                : path_1.default.join(getActualWorkingDirectory(), outputFile);
            if (fullPath === outputAbsPath ||
                (useDefaultIgnores && defaultIgnore.ignores(relativePath))) {
                defaultIgnoredCount++;
            }
            else if (customIgnores[sourceDir].ignores(relativePath)) {
                customIgnoredCount++;
            }
            else {
                // Get file size for stats
                const stats = await fs_1.promises.stat(fullPath);
                fileSizes[displayPath] = stats.size;
                if ((await (0, utils_1.isTextFile)(fullPath)) && !(0, utils_1.shouldTreatAsBinary)(fullPath)) {
                    let content = await fs_1.promises.readFile(fullPath, "utf-8");
                    const extension = path_1.default.extname(relativePath);
                    content = (0, utils_1.escapeTripleBackticks)(content);
                    if (removeWhitespaceFlag &&
                        !utils_1.WHITESPACE_DEPENDENT_EXTENSIONS.includes(extension)) {
                        content = (0, utils_1.removeWhitespace)(content);
                    }
                    output += `# ${displayPath}\n\n`;
                    output += `\`\`\`${extension.slice(1) || ""}\n`;
                    output += content;
                    output += "\n\`\`\`\n\n";
                    includedCount++;
                    includedFiles.push(displayPath);
                }
                else {
                    const fileType = (0, utils_1.getFileType)(fullPath);
                    output += `# ${displayPath}\n\n`;
                    if (fileType === "SVG Image") {
                        output += `This is a file of the type: ${fileType}\n\n`;
                    }
                    else {
                        output += `This is a binary file of the type: ${fileType}\n\n`;
                    }
                    binaryAndSvgFileCount++;
                    includedCount++;
                    includedFiles.push(displayPath);
                }
            }
        }
        await fs_1.promises.mkdir(path_1.default.dirname(path_1.default.resolve(getActualWorkingDirectory(), outputFile)), { recursive: true });
        // Write to a temporary file first to prevent partial writes during SIGINT
        const tempFile = `${outputFile}.temp`;
        await fs_1.promises.writeFile(tempFile, output, { flag: "w" });
        // Verify the write was successful before moving
        const stats = await fs_1.promises.stat(tempFile);
        const fileSizeInBytes = stats.size;
        if (stats.size !== Buffer.byteLength(output)) {
            // Clean up and throw error
            await fs_1.promises.unlink(tempFile).catch(() => { });
            throw new Error("File size mismatch after writing");
        }
        // Atomically rename the temp file to the target file
        // This ensures the file is either fully written or not changed at all
        await fs_1.promises.rename(tempFile, outputFile);
        console.log((0, utils_1.formatLog)(`Files aggregated successfully into ${outputFile}`, "‚úÖ"));
        console.log((0, utils_1.formatLog)(`Total files found: ${allFileEntries.length}`, "üìö"));
        console.log((0, utils_1.formatLog)(`Files included in output: ${includedCount}`, "üìé"));
        if (useDefaultIgnores) {
            console.log((0, utils_1.formatLog)(`Files ignored by default patterns: ${defaultIgnoredCount}`, "üö´"));
        }
        if (customIgnoredCount > 0) {
            console.log((0, utils_1.formatLog)(`Files ignored by .aidigestignore: ${customIgnoredCount}`, "üö´"));
        }
        console.log((0, utils_1.formatLog)(`Binary and SVG files included: ${binaryAndSvgFileCount}`, "üì¶"));
        if (fileSizeInBytes > MAX_FILE_SIZE) {
            console.log((0, utils_1.formatLog)(`Warning: Output file size (${(fileSizeInBytes / 1024 / 1024).toFixed(2)} MB) exceeds 10 MB.`, "‚ö†Ô∏è"));
            console.log((0, utils_1.formatLog)("Token count estimation skipped due to large file size.", "‚ö†Ô∏è"));
            console.log((0, utils_1.formatLog)("Consider adding more files to .aidigestignore to reduce the output size.", "üí°"));
        }
        else {
            const { gptTokens, claudeTokens } = (0, utils_1.estimateTokenCount)(output);
            console.log((0, utils_1.formatLog)(`Estimated token counts - Claude models: ${claudeTokens} tokens, GPT-4: ${gptTokens} tokens`, "üî¢"));
        }
        if (showOutputFiles) {
            // Check if we should sort by size
            const sortBySize = showOutputFiles === "sort";
            displayIncludedFiles(includedFiles, fileSizes, sortBySize);
        }
        console.log((0, utils_1.formatLog)(`Done! Wrote code base to ${outputFile}`, "‚úÖ"));
    }
    catch (error) {
        console.error((0, utils_1.formatLog)("Error aggregating files:", "‚ùå"), error);
        process.exit(1);
    }
}
// Read package.json to get the version
const packageJsonPath = path_1.default.join(__dirname, "..", "package.json");
const packageJson = JSON.parse(fsSync.readFileSync(packageJsonPath, "utf-8"));
commander_1.program
    .version(packageJson.version)
    .description("Aggregate files into a single Markdown file")
    .option("-i, --input <directories...>", "Input directories (multiple allowed)", [getActualWorkingDirectory()] // Fix: Use getActualWorkingDirectory() instead of process.cwd()
)
    .option("-o, --output <file>", "Output file name", "codebase.md")
    .option("--no-default-ignores", "Disable default ignore patterns")
    .option("--whitespace-removal", "Enable whitespace removal")
    .option("--show-output-files [sort]", "Display a list of files included in the output, optionally sorted by size ('sort')")
    .option("--ignore-file <file>", "Custom ignore file name", ".aidigestignore")
    .option("--watch", "Watch for file changes and rebuild automatically")
    .action(async (options) => {
    const inputDirs = options.input.map((dir) => path_1.default.resolve(dir));
    // Fix: Use getActualWorkingDirectory() instead of process.cwd()
    const outputFile = path_1.default.isAbsolute(options.output)
        ? options.output
        : path_1.default.join(getActualWorkingDirectory(), options.output);
    if (options.watch) {
        // Run in watch mode
        await watchFiles(inputDirs, outputFile, options.defaultIgnores, options.whitespaceRemoval, options.showOutputFiles, options.ignoreFile, process.env.NODE_ENV === "test" // Pass test mode flag based on environment
        );
    }
    else {
        // Run once
        await aggregateFiles(inputDirs, outputFile, options.defaultIgnores, options.whitespaceRemoval, options.showOutputFiles, options.ignoreFile);
    }
});
commander_1.program.parse(process.argv);
